/**
 This Source Code is licensed under the MIT license. If a copy of the
 MIT-license was not distributed with this file, You can obtain one at:
 http://opensource.org/licenses/mit-license.html.

 @author: Hans van den Akker (mysim1)
 @license MIT
 @copyright Bizboard, 2015

 */

import {provide}                from 'di';
import {DataSource}             from '../core/DataSource.js';
import Timer                    from 'famous/utilities/Timer';
import EventEmitter             from 'eventemitter3';
import _                        from 'lodash';
import {MockedSnapshot}         from './Mocked/MockedSnapshot.js';

@provide(DataSource)
export class MockedDataSource extends DataSource {

    /**
     * Receive a set of data for the MockedDataSource to emit data to the subscribing components.
     * @param dataSet
     * @param options
     */
    constructor(path, options = { orderBy: '.priority', dataSet: []}) {
        super();

        this._dataReference = new EventEmitter();
        this._onValueCallback = null;
        this._onAddCallback = null;
        this._onChangeCallback = null;
        this._onMoveCallback = null;
        this._onRemoveCallback = null;
        this.options = options;
        //this._dataSet = dataSet;


        if (this.options.dataSet instanceof Array)
        {

            Timer.setTimeout(function () {
                    if (this._dataReference) {
                        this._dataReference.emit('value', this.options.dataSet);
                    }

                    for (let record in this.options.dataSet) {
                        Timer.setTimeout(function () {
                                this._dataReference.emit('child_added', this.options.dataSet[record]);
                            }.bind(this),
                            10);
                    }
                }.bind(this),
                200);
        }
    }



    /**
     * Returns the full path to this dataSource's source on the remote storage provider.
     * @returns {String} Full resource path.
     */
    toString() {
        return 'mocked://';
    }

    /**
     * Returns a dataSource reference to the given child branch of the current dataSource.
     * @param {String} childName Child branch name.
     * @param {Object} options Optional: additional options to pass to new DataSource instance.
     * @returns {DataSource} New dataSource instance pointing to the given child branch.
     */
    child(childName, options = null) {
        let childPath = '';
        childPath += this._orginialPath + '/' + childName;
        return new MockedDataSource(childPath, options || this.options);
    }

    /**
     * Returns the full URL to the path on the dataSource. Functionally identical to toString().
     * @returns {String} Full resource path.
     */
    path() {
        return 'mocked://';
    }

    /**
     * Returns the name of the current branch in the path on the dataSource.
     * @returns {String} Current branch name.
     */
    key() {
        let url = 'mocked://';
        if (url.path.length === 0) { return ''; }
        var pathElements = url.path.split('/');
        if (pathElements.length === 1) {
            return url.path;
        } else {
            return url.path.split('/').pop();
        }
    }

    /**
     * Writes newData to the path this dataSource was constructed with.
     * @param {Object} newData Data to write to dataSource.
     * @returns {void}
     */
    set(newData) {

        let isNew =  _.findIndex(this.options.dataSet, function (record) {
            return record.id == newData.id;
        });

        if (isNew>-1) {
            this.options.dataSet[isNew] = newData;
            this._dataReference.emit('child_changed', newData);
        }
        else {
            this.options.dataSet.push(newData);
            this._dataReference.emit('child_added', newData);
        }

        return new MockedDataSource(newData);
    }

    /**
     * Removes the object and all underlying children that this dataSource points to.
     * @returns {void}
     */
    remove() {
        // TODO: not sure how we should handle this scenario
    }

    /**
     * Writes newData to the path this dataSource was constructed with, appended by a random UID generated by
     * the dataSource.
     * @param {Object} newData New data to append to dataSource.
     * @returns {void}
     */
    push(newData) {
        return this.set(newData);
    }

    /**
     * Writes newData with given priority (ordering) to the path this dataSource was constructed with.
     * @param {Object} newData New data to set.
     * @param {String|Number} priority Priority value by which the data should be ordered.
     * @returns {void}
     */
    setWithPriority(newData, priority) {
        newData.priority = priority;
        this.set(newData);
    }

    /**
     * Sets the priority (ordering) of an object on a given dataSource.
     * @param {String|Number} newPriority New priority value to order data by.
     * @returns {void}
     */
    setPriority(newPriority) {
        throw new Error('Not implemented');
    }

    /**
     * Returns a new dataSource reference that will limit the subscription to only the first given amount items.
     * @param {Number} amount Amount of items to limit the dataSource to.
     * @returns {DataSource} New dataSource instance.
     */
    limitToFirst(amount) {
        throw new Error('Not implemented');
    }

    /**
     * Returns a new dataSource reference that will limit the subscription to only the last given amount items.
     * @param {Number} amount Amount of items to limit the dataSource to.
     * @returns {DataSource} New dataSource instance.
     */
    limitToLast(amount) {
        throw new Error('Not implemented');
    }

    /**
     * Authenticates all instances of this DataSource with the given OAuth provider and credentials.
     * @param {String} provider google, facebook, github, or twitter
     * @param {String|Object} credentials Access token string, or object with key/value pairs with e.g. OAuth 1.1 credentials.
     * @param {Function} onComplete Callback, executed when login is completed either successfully or erroneously.
     * On error, first argument is error message.
     * On success, the first argument is null, and the second argument is an object containing the fields uid, provider, auth, and expires.
     * @param {Object} options Optional, additional client arguments, such as configuring session persistence.
     * @returns {void}
     */
    authWithOAuthToken(provider, credentials, onComplete, options) {}

    /**
     * Authenticates all instances of this DataSource with a custom auth token or secret.
     * @param {String} authToken Authentication token or secret.
     * @param {Function} onComplete Callback, executed when login is completed either successfully or erroneously.
     * On error, first argument is error message.
     * On success, the first argument is null, and the second argument is an object containing the fields uid, provider, auth, and expires.
     * @param {Object} options Optional, additional client arguments, such as configuring session persistence.
     * @returns {void}
     */
    authWithCustomToken(authToken, onComplete, options) { }

    /**
     * Authenticates all instances of this DataSource with the given email/password credentials.
     * @param {String|Object} credentials Object with key/value pairs {email: "value", password:"value"}.
     * @param {Function} onComplete Callback, executed when login is completed either successfully or erroneously.
     * On error, first argument is error message.
     * On success, the first argument is null, and the second argument is an object containing the fields uid, provider, auth, and expires.
     * @param {Object} options Optional, additional client arguments, such as configuring session persistence.
     * @returns {void}
     */
    authWithPassword(credentials, onComplete, options) { }

    /**
     * Fetches the current user's authentication state.
     * If the user is authenticated, returns an object containing at least the fields uid, provider, auth, and expires.
     * If the user is not authenticated, returns null.
     * @returns {Object|null} User auth object.
     */
    getAuth() {
        return { uid: 'mocked', provider: 'mocked', auth: '', expires: '' }
    }

    /**
     * Logs out from the datasource, allowing to re-authenticate at a later time.
     * @returns {void}
     */
    unauth() { }

    /**
     * Sets the callback triggered when dataSource updates the data.
     * @param {Function} callback Callback function to call when the subscribed data value changes.
     * @returns {void}
     **/
    setValueChangedCallback(callback) {
        this._onValueCallback = (data) => {
            let newChildSnapshot = new MockedSnapshot(data, this);
            callback(newChildSnapshot);
        };
        this._dataReference.on('value', this._onValueCallback);
    }

    /**
     * Removes the callback set to trigger when dataSource updates the data.
     * @returns {void}
     **/
    removeValueChangedCallback() {
        if (this._onValueCallback) {
            this._dataReference.off('value', this._onValueCallback);
            this._onValueCallback = null;
        }
    }

    /**
     * Set the callback triggered when dataSource adds a data element.
     * @param {Function} callback Callback function to call when a new data child is added.
     * @returns {void}
     **/
    setChildAddedCallback(callback) {
        this._onAddCallback = (data, previousSiblingId) => {
            let newChildSnapshot = new MockedSnapshot(data, this);
            callback(newChildSnapshot, previousSiblingId);
        };
        this._dataReference.on('child_added', this._onAddCallback);
    }

    /**
     * Removes the callback set to trigger when dataSource adds a data element.
     * @returns {void}
     **/
    removeChildAddedCallback() {
        if (this._onAddCallback) {
            this._dataReference.off('child_added', this._onAddCallback);
            this._onAddCallback = null;
        }
    }

    /**
     * Set the callback triggered when dataSource changes a data element.
     * @param {Function} callback Callback function to call when a child is changed.
     * @returns {void}
     **/
    setChildChangedCallback(callback) {
        this._onChangeCallback = (data, previousSiblingId) => {
            let newChildSnapshot = new MockedSnapshot(data, this);
            callback(newChildSnapshot, previousSiblingId);
        };
        this._dataReference.on('child_changed', this._onChangeCallback);
    }

    /**
     * Removes the callback set to trigger when dataSource changes a data element.
     * @returns {void}
     **/
    removeChildChangedCallback() {
        if (this._onChangeCallback) {
            this._dataReference.off('child_changed', this._onChangeCallback);
            this._onChangeCallback = null;
        }
    }

    /**
     * Set the callback triggered when dataSource moves a data element.
     * @param {Function} callback Callback function to call when a child is moved.
     * @returns {void}
     **/
    setChildMovedCallback(callback) { console.warn('Not implemented'); }

    /**
     * Removes the callback set to trigger when dataSource moves a data element.
     * @returns {void}
     **/
    removeChildMovedCallback() { console.warn('Not implemented'); }

    /**
     * Set the callback triggered when dataSource removes a data element.
     * @param {Function} callback Callback function to call when a child is removed.
     * @returns {void}
     **/
    setChildRemovedCallback(callback) {
        this._onRemoveCallback = (data) => {
            let removedChildSnapshot = new MockedSnapshot(data, this);
            callback(removedChildSnapshot);
        };

        this._dataReference.on('child_removed', this._onRemoveCallback);
    }

    /**
     * Removes the callback set to trigger when dataSource removes a data element.
     * @returns {void}
     **/
    removeChildRemovedCallback() {
        if (this._onRemoveCallback) {
            this._dataReference.off('child_removed', this._onRemoveCallback);
            this._onRemoveCallback = null;
        }
    }
}